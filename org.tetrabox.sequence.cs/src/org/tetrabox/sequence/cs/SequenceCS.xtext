// automatically generated by Xtext
grammar org.tetrabox.sequence.cs.SequenceCS with org.eclipse.xtext.common.Terminals

import "platform:/resource/org.tetrabox.sequence.model/model/sequence.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SERE:
	SimpleSERE (':' {FusionSERE.left=current} right=SERE | ';' {ConcatenationSERE.left=current} right=SERE)
;

SimpleSERE:
	SequenceTerminal
	| Sequence
	| CompoundSERE
;

SequenceTerminal:
	{NotSequenceTerminal} 'not' literal=SequenceTerminal
	| {BooleanLiteral} (literal?='true' | 'false')
	| {OCLExpression} 'ocl' expression=STRING
;

Sequence:
	BracedSERE | RepeatedSERE;

RepeatedSERE:
	{BooleanCountedConsecutiveRepetition} expression=SequenceTerminal (=>'[' '*') count=Count? ']'
	| {SequenceCountedConsecutiveRepetition} expression=BracedSERE (=>'[' '*') count=Count? ']'
	| {SequenceCountedConsecutiveRepetition} '(' expression=RepeatedSERE ')' (=>'[' '*') count=Count? ']'
	| {BooleanConsecutiveRepetition} expression=SequenceTerminal (=>'[' '+') ']'
	| {SequenceConsecutiveRepetition} expression=BracedSERE (=>'[' '+') ']'
	| {SequenceConsecutiveRepetition} '(' expression=RepeatedSERE ')' (=>'[' '+') ']'
	| {BooleanCountedNonConsecutiveRepetition} expression=SequenceTerminal (=>'[' '=') count=Count ']'
	| {BooleanCountedGotoRepetition} expression=SequenceTerminal (=>'[' '->') count=Count? ']'
	| {WildCard} '[' '*' count=Count? ']'
	| {LengthOne} '[' '+' ']'
;

BracedSERE:
	'{' expression=SERE '}';

CompoundSERE:
	RepeatedSERE
	| BracedSERE
	| BinaryCompoundSERE
;

BinaryCompoundSERE:
	{SEREOr} (left=RepeatedSERE | left=BracedSERE | '(' left=BinaryCompoundSERE ')') ->'|' (right=RepeatedSERE | right=BracedSERE | '(' right=BinaryCompoundSERE ')')
	| {SEREAndNLM} (left=RepeatedSERE | left=BracedSERE | '(' left=BinaryCompoundSERE ')') ->'&' (right=RepeatedSERE | right=BracedSERE | '(' right=BinaryCompoundSERE ')')
	| {SEREAndLM} (left=RepeatedSERE | left=BracedSERE | '(' left=BinaryCompoundSERE ')') ->'&&' (right=RepeatedSERE | right=BracedSERE | '(' right=BinaryCompoundSERE ')')
	| {SEREWithin} (left=RepeatedSERE | left=BracedSERE | '(' left=BinaryCompoundSERE ')') ->'within' (right=RepeatedSERE | right=BracedSERE | '(' right=BinaryCompoundSERE ')')
;

Count:
	COUNT=NUMBER | Range;

Range:
	LOWER_BOUND = NUMBER ':' HIGHER_BOUND = NUMBER;

NUMBER returns ecore::EInt :
	INT;

FQN returns ecore::EString :
	ID ('.' ID)*
;